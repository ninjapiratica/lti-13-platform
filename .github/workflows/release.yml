name: Pack, Tag & Publish

on:
  workflow_dispatch:
    inputs:
      new_major:
        description: "Is this a new major release?"
        required: false
        default: "false"
      new_minor:
        description: "Is this a new minor release?"
        required: false
        default: "false"
      preview:
        description: "Is this a preview release?"
        required: false
        default: "false"
      dryrun:
        description: "Is this a dry-run?"
        required: false
        default: "false"
      version_override:
        description: "Override the computed version (use exact version string)"
        required: false
        default: ""

permissions: 
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest

    permissions:
      id-token: write  # enable GitHub OIDC token issuance for this job
      contents: write  # allow pushing tags and creating releases using GITHUB_TOKEN
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Print workflow inputs
        run: |
          echo "Workflow inputs (as received)"
          echo "new_major=${{ github.event.inputs.new_major }}"
          echo "new_minor=${{ github.event.inputs.new_minor }}"
          echo "preview=${{ github.event.inputs.preview }}"
          echo "dryrun=${{ github.event.inputs.dryrun }}"
          echo "version_override=${{ github.event.inputs.version_override }}"

      - name: Determine .NET version from csproj
        id: dotnet-version
        run: |
          PROJECT_FILE=$(find . -name "*.csproj" | head -n 1)
          if [ -z "$PROJECT_FILE" ]; then
            echo "No .csproj file found!" >&2
            exit 1
          fi

          if grep -q "<TargetFrameworks>" "$PROJECT_FILE"; then
            TF=$(grep -oPm1 "(?<=<TargetFrameworks>)[^<]+" "$PROJECT_FILE" | cut -d';' -f1)
          else
            TF=$(grep -oPm1 "(?<=<TargetFramework>)[^<]+" "$PROJECT_FILE")
          fi

          if [ -z "$TF" ]; then
            echo "Failed to parse TargetFramework from $PROJECT_FILE" >&2
            exit 1
          fi

          DOTNET_VERSION="${TF#net}.x"
          echo "Using .NET version: $DOTNET_VERSION"
          echo "DOTNET_VERSION=$DOTNET_VERSION" >> $GITHUB_OUTPUT

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ steps.dotnet-version.outputs.DOTNET_VERSION }}

      - name: Compute next semantic version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version_override }}" ]; then
            # Use explicit override and ignore other rules
            VERSION="${{ github.event.inputs.version_override }}"
          else
            # Find the latest non-preview tag (tags like v1.2.3). If none, default to v0.0.0
            LAST_TAG=$(git tag --list --sort=-v:refname 'v*' | grep -v -E '-preview' | head -n1 || true)
            if [ -z "$LAST_TAG" ]; then
              LAST_TAG="v0.0.0"
            fi

            CLEAN_TAG=${LAST_TAG#v}

            # Ensure CLEAN_TAG is a valid semver x.y.z; otherwise fall back to 0.0.0
            if ! echo "$CLEAN_TAG" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              CLEAN_TAG="0.0.0"
            fi

            IFS='.' read -r MAJOR MINOR PATCH <<< "$CLEAN_TAG"

            MAJOR=${MAJOR:-0}
            MINOR=${MINOR:-0}
            PATCH=${PATCH:-0}

            # Bump according to inputs, always based on the last non-preview version
            if [ "${{ github.event.inputs.new_major }}" = "true" ]; then
              MAJOR=$((MAJOR+1))
              MINOR=0
              PATCH=0
            elif [ "${{ github.event.inputs.new_minor }}" = "true" ]; then
              MINOR=$((MINOR+1))
              PATCH=0
            else
              PATCH=$((PATCH+1))
            fi

            VERSION="$MAJOR.$MINOR.$PATCH"

            # Append preview suffix when requested
            if [ "${{ github.event.inputs.preview }}" = "true" ]; then
              VERSION="$VERSION-preview.${{ github.run_number }}"
            fi
          fi

          echo "Computed version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set package list and derive package names
        id: package-list
        run: |
          # Single authoritative list: one project per array entry (easy to read)
          PROJS=(
            "NP.Lti13Platform.Core/NP.Lti13Platform.Core.csproj"
            "NP.Lti13Platform.AssignmentGradeServices/NP.Lti13Platform.AssignmentGradeServices.csproj"
            "NP.Lti13Platform.DeepLinking/NP.Lti13Platform.DeepLinking.csproj"
            "NP.Lti13Platform.NameRoleProvisioningServices/NP.Lti13Platform.NameRoleProvisioningServices.csproj"
            "NP.Lti13Platform/NP.Lti13Platform.csproj"
          )

          # Export a space-separated single-line output for downstream steps
          PROJECTS_SINGLE="$(printf "%s " "${PROJS[@]}")"
          PROJECTS_SINGLE=${PROJECTS_SINGLE% } # trim trailing space
          echo "projects=$PROJECTS_SINGLE" >> $GITHUB_OUTPUT

          # Derive package ids (prefer <PackageId>, then <AssemblyName>, then filename)
          NAMES=()
          for proj in "${PROJS[@]}"; do
            # trim just in case
            proj="$(echo "$proj" | xargs)"
            [ -z "$proj" ] && continue
            if [ -f "$proj" ]; then
              pkg=$(grep -oPm1 "(?<=<PackageId>)[^<]+" "$proj" || true)
              if [ -z "$pkg" ]; then
                pkg=$(grep -oPm1 "(?<=<AssemblyName>)[^<]+" "$proj" || true)
              fi
              if [ -z "$pkg" ]; then
                pkg=$(basename "$proj" .csproj)
              fi
            else
              pkg=$(basename "$proj" .csproj)
            fi
            NAMES+=("$pkg")
          done

          joined="$(printf "%s " "${NAMES[@]}")"
          joined=${joined% } # trim trailing space
          echo "names=$joined" >> $GITHUB_OUTPUT
          echo "Derived package names: $joined"

      - name: Dry run - print planned values
        if: ${{ github.event.inputs.dryrun == 'true' }}
        run: |
          echo "DRY RUN: no actions will be performed"
          echo "--- Determined .NET version ---"
          echo "DOTNET_VERSION=${{ steps.dotnet-version.outputs.DOTNET_VERSION }}"
          echo "--- Computed semantic version ---"
          echo "VERSION=${{ steps.version.outputs.version }}"
          echo "--- Projects to pack ---"
          echo "PROJECTS=${{ steps.package-list.outputs.projects }}"
          echo "--- Derived package names ---"
          echo "NAMES=${{ steps.package-list.outputs.names }}"
          echo "--- Tag that would be created ---"
          echo "TAG=v${{ steps.version.outputs.version }}"

      - name: Restore dependencies
        if: ${{ github.event.inputs.dryrun != 'true' }}
        run: dotnet restore

      - name: Build
        if: ${{ github.event.inputs.dryrun != 'true' }}
        run: dotnet build --configuration Release --no-restore /p:Version=${{ steps.version.outputs.version }} /p:PackageVersion=${{ steps.version.outputs.version }}

      - name: Pack NuGet
        if: ${{ github.event.inputs.dryrun != 'true' }}
        run: |
          VERSION=${{ steps.version.outputs.version }}
          IFS=' ' read -r -a PROJS <<< "${{ steps.package-list.outputs.projects }}"
          for proj in "${PROJS[@]}"; do
            echo "Packing $proj..."
            dotnet pack "$proj" --configuration Release -o ./artifacts /p:Version=$VERSION /p:PackageVersion=$VERSION
          done

      # Get a short-lived NuGet API key
      - name: NuGet login (OIDC → temp API key)
        uses: NuGet/login@v1
        id: nuget_login
        with:
          user: ${{ secrets.NUGET_USER }}
        if: ${{ github.event.inputs.dryrun != 'true' }}
    
      - name: Push NuGet packages
        env:
          NUGET_API_KEY: ${{ steps.nuget_login.outputs.NUGET_API_KEY }}
        if: ${{ github.event.inputs.dryrun != 'true' }}
        run: |
          VERSION=${{ steps.version.outputs.version }}
          IFS=' ' read -r -a PKG_NAMES <<< "${{ steps.package-list.outputs.names }}"
          for name in "${PKG_NAMES[@]}"; do
            pkg="${name}.${VERSION}.nupkg"
            if [ -f "./artifacts/$pkg" ]; then
              echo "Pushing $pkg..."
              dotnet nuget push "./artifacts/$pkg" --source https://api.nuget.org/v3/index.json --api-key $NUGET_API_KEY
            else
              echo "Warning: $pkg not found, skipping..."
            fi
          done

      - name: Create tag
        if: ${{ github.event.inputs.dryrun != 'true' }}
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          git tag $TAG
          git push origin $TAG

      - name: Create GitHub Release
        if: ${{ github.event.inputs.dryrun != 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: Release v${{ steps.version.outputs.version }}
          prerelease: ${{ github.event.inputs.preview }}
          generate_release_notes: true

        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
