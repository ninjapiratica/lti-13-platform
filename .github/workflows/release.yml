name: Pack, Tag & Publish

on:
  workflow_dispatch:
    inputs:
      new_major:
        description: "Is this a new major release?"
        required: false
        default: "false"
      new_minor:
        description: "Is this a new minor release?"
        required: false
        default: "false"
      preview:
        description: "Is this a preview release?"
        required: false
        default: "false"
      version_override:
        description: "Override the computed version (use exact version string)"
        required: false
        default: ""

permissions: 
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Determine .NET version from csproj
        id: dotnet-version
        run: |
          PROJECT_FILE=$(find . -name "*.csproj" | head -n 1)
          if [ -z "$PROJECT_FILE" ]; then
            echo "No .csproj file found!" >&2
            exit 1
          fi

          if grep -q "<TargetFrameworks>" "$PROJECT_FILE"; then
            TF=$(grep -oPm1 "(?<=<TargetFrameworks>)[^<]+" "$PROJECT_FILE" | cut -d';' -f1)
          else
            TF=$(grep -oPm1 "(?<=<TargetFramework>)[^<]+" "$PROJECT_FILE")
          fi

          if [ -z "$TF" ]; then
            echo "Failed to parse TargetFramework from $PROJECT_FILE" >&2
            exit 1
          fi

          DOTNET_VERSION="${TF#net}.x"
          echo "Using .NET version: $DOTNET_VERSION"
          echo "DOTNET_VERSION=$DOTNET_VERSION" >> $GITHUB_OUTPUT

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ steps.dotnet-version.outputs.DOTNET_VERSION }}

      - name: Compute next semantic version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version_override }}" ]; then
            VERSION="${{ github.event.inputs.version_override }}"
          else
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            CLEAN_TAG=${LAST_TAG#v}
            CLEAN_TAG=${CLEAN_TAG%%-preview*}

            IFS='.' read -r MAJOR MINOR PATCH <<< "$CLEAN_TAG"

            if [ "${{ github.event.inputs.new_major }}" = "true" ]; then
              MAJOR=$((MAJOR+1))
              MINOR=0
              PATCH=0
            elif [ "${{ github.event.inputs.new_minor }}" = "true" ]; then
              MINOR=$((MINOR+1))
              PATCH=0
            else
              PATCH=$((PATCH+1))
            fi

            VERSION="$MAJOR.$MINOR.$PATCH"

            if [ "${{ github.event.inputs.preview }}" = "true" ]; then
              VERSION="$VERSION-preview.${{ github.run_number }}"
            fi
          fi

          echo "Computed version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set package list and derive package names
        id: package-list
        run: |
          # Single authoritative list: one project per array entry (easy to read)
          PROJS=(
            "NP.Lti13Platform.Core/NP.Lti13Platform.Core.csproj"
            "NP.Lti13Platform.AssignmentGradeServices/NP.Lti13Platform.AssignmentGradeServices.csproj"
            "NP.Lti13Platform.DeepLinking/NP.Lti13Platform.DeepLinking.csproj"
            "NP.Lti13Platform.NameRoleProvisioningServices/NP.Lti13Platform.NameRoleProvisioningServices.csproj"
            "NP.Lti13Platform/NP.Lti13Platform.csproj"
          )

          # Export a space-separated single-line output for downstream steps
          PROJECTS_SINGLE="$(printf "%s " "${PROJS[@]}")"
          PROJECTS_SINGLE=${PROJECTS_SINGLE% } # trim trailing space
          echo "projects=$PROJECTS_SINGLE" >> $GITHUB_OUTPUT

          # Derive package ids (prefer <PackageId>, then <AssemblyName>, then filename)
          NAMES=()
          for proj in "${PROJS[@]}"; do
            # trim just in case
            proj="$(echo "$proj" | xargs)"
            [ -z "$proj" ] && continue
            if [ -f "$proj" ]; then
              pkg=$(grep -oPm1 "(?<=<PackageId>)[^<]+" "$proj" || true)
              if [ -z "$pkg" ]; then
                pkg=$(grep -oPm1 "(?<=<AssemblyName>)[^<]+" "$proj" || true)
              fi
              if [ -z "$pkg" ]; then
                pkg=$(basename "$proj" .csproj)
              fi
            else
              pkg=$(basename "$proj" .csproj)
            fi
            NAMES+=("$pkg")
          done

          joined="$(printf "%s " "${NAMES[@]}")"
          joined=${joined% } # trim trailing space
          echo "names=$joined" >> $GITHUB_OUTPUT
          echo "Derived package names: $joined"

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --configuration Release --no-restore /p:Version=${{ steps.version.outputs.version }} /p:PackageVersion=${{ steps.version.outputs.version }}

      - name: Pack NuGet
        run: |
          VERSION=${{ steps.version.outputs.version }}
          IFS=' ' read -r -a PROJS <<< "${{ steps.package-list.outputs.projects }}"
          for proj in "${PROJS[@]}"; do
            echo "Packing $proj..."
            dotnet pack "$proj" --configuration Release -o ./artifacts /p:Version=$VERSION /p:PackageVersion=$VERSION
          done

      - name: Push NuGet packages
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          VERSION=${{ steps.version.outputs.version }}
          IFS=' ' read -r -a PKG_NAMES <<< "${{ steps.package-list.outputs.names }}"
          for name in "${PKG_NAMES[@]}"; do
            pkg="${name}.${VERSION}.nupkg"
            if [ -f "./artifacts/$pkg" ]; then
              echo "Pushing $pkg..."
              dotnet nuget push "./artifacts/$pkg" --source https://api.nuget.org/v3/index.json --api-key $NUGET_API_KEY
            else
              echo "Warning: $pkg not found, skipping..."
            fi
          done

      - name: Create tag
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          git tag $TAG
          git push origin $TAG

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: Release v${{ steps.version.outputs.version }}
          prerelease: ${{ github.event.inputs.preview }}
          generate_release_notes: true

        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
