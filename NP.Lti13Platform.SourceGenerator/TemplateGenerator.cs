using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

[Generator]
public sealed class TemplateGenerator : IIncrementalGenerator
{
    /*
     * Placeholders in templates:
     * "TYPE_KEYWORD" = record struct, record, class, struct, interface, etc.
     * "TYPE_NAME" = typeName
     */

    private static readonly HashSet<string> AttributeNames =
    [
        "StringId",
    ];

    // The comment to prepend to generated files
    private const string GeneratedFileComment = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the TemplateGenerator source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591 // publicly visible type or member must be documented

#nullable enable
";

    public void Initialize(IncrementalGeneratorInitializationContext initContext)
    {
        // Find all type declarations with at least one attribute
        var candidateTypes = initContext.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) =>
                    node is TypeDeclarationSyntax tds &&
                    tds.AttributeLists.Count > 0,
                transform: static (ctx, _) =>
                {
                    var typeDecl = (TypeDeclarationSyntax)ctx.Node;
                    // Collect all attribute names on the type
                    var attributeNames = typeDecl.AttributeLists
                        .SelectMany(al => al.Attributes)
                        .Select(attr =>
                        {
                            var name = attr.Name.ToString();
                            // Remove "Attribute" suffix if present
                            if (name.EndsWith("Attribute"))
                                name = name.Substring(0, name.Length - 9);
                            return name;
                        })
                        .ToList();

                    return (typeDecl, attributeNames);
                })
            .Where(static t => t.typeDecl is not null && t.attributeNames.Count > 0)
            // Filter: Only include types with at least one attribute in AttributeNames
            .Where(t => t.attributeNames.Any(attr => AttributeNames.Contains(attr)));

        // Generate source for each type and each attribute using its template
        initContext.RegisterSourceOutput(candidateTypes.Collect(), (spc, typeDecls) =>
        {
            foreach (var (typeDecl, attributeNames) in typeDecls)
            {
                var typeName = typeDecl.Identifier.Text;

                // Determine the full type keyword, handling combinations like "record struct"
                var typeKeyword = typeDecl switch
                {
                    RecordDeclarationSyntax recordDecl => recordDecl.ClassOrStructKeyword.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StructKeyword)
                        ? "record struct"
                        : "record",
                    ClassDeclarationSyntax => "class",
                    StructDeclarationSyntax => "struct",
                    InterfaceDeclarationSyntax => "interface",
                    _ => typeDecl.Kind().ToString().Replace("Declaration", "").ToLowerInvariant()
                };

                // Find the namespace declaration
                string? ns = null;
                var parent = typeDecl.Parent;
                while (parent != null)
                {
                    if (parent is BaseNamespaceDeclarationSyntax nsDecl)
                    {
                        ns = nsDecl.Name.ToString();
                        break;
                    }
                    parent = parent.Parent;
                }

                foreach (var attrName in attributeNames)
                {
                    // Template resource name: LMS.SourceGenerator.<AttributeName>.tpl
                    var resourceName = $"NP.Lti13Platform.SourceGenerator.{attrName}.tpl";
                    var assembly = Assembly.GetExecutingAssembly();
                    string? templateText = null;
                    using (var stream = assembly.GetManifestResourceStream(resourceName))
                    {
                        if (stream == null)
                            continue; // Skip if template not found

                        using var reader = new StreamReader(stream);
                        templateText = reader.ReadToEnd();
                    }

                    if (string.IsNullOrEmpty(templateText))
                        continue;

                    // Compose the generated code with file-scoped namespace
                    var generatedBody = templateText
                        .Replace("TYPE_NAME", typeName)
                        .Replace("TYPE_KEYWORD", typeKeyword);

                    // Build fully qualified name for the generated file
                    var fileName = typeName;
                    var namespaceDeclaration = string.Empty;
                    if (!string.IsNullOrWhiteSpace(ns))
                    {
                        namespaceDeclaration = $"namespace {ns};\r\n";
                        fileName = $"{ns}.{typeName}";
                    }

                    spc.AddSource($"{fileName}_{attrName}_Generated.g.cs", string.Join("\r\n", [GeneratedFileComment, namespaceDeclaration, generatedBody]));
                }
            }
        });
    }
}